package application;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.InetAddress;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.sql.Time;

/**
 * This class handles all the connections of the clients towards the server.
 * @author fredrikjohansson
 *
 */
public class ToServer extends TCP{
	private static int			threadCounter = 0;
	private String				nick;
	private String				topic;
	private byte[]				cryptKey;
	
	/**
	 * This is the constructor of class ToServer witch sets up the ToServer
	 * for future connection.
	 * @param server_ip Represents the servers IP in string format.
	 * @param server_port The server port on the server in string format.
	 * @param topic A string with the server topic.
	 */
	public ToServer(String server_ip, int server_port, String topic){
		super("Client thread " + threadCounter++, server_ip, server_port);
		this.nick = null;
		this.topic = topic;
		this.cryptKey = new byte[0];
	}
	
	/**
	 * Connects the client to the serve with the preferred nickname.
	 * @param nick The preferred nickname.
	 * @throws UnknownHostException Throws when the super class TCP can't find the
	 * server.
	 * @throws IOException Is thrown when trying to connect or send to a server
	 * witch dosn't have an accept-socket open for incoming connection or the connection
	 * is down for sending packages. 
	 */
	public void connect(String nick) throws UnknownHostException, IOException{
		this.nick = nick;
		super.connect();
		super.send(PDU_Factory.join(nick).getBytes());
	}

	/**
	 * Is called by the super class TCP when it receives a message from the server.
	 * After receiving the bytes this method checks the OpCode of the message and depending
	 * on the code it uses different cases to interpret the message act there after.
	 * @param bytes The bytes received from the connected server.
	 * @param bytesRead Number of bytes read.
	 * @throws IOException Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations. 
	 */
	@Override
	public void receive(byte[] bytes, int bytesRead) throws IOException{
		
		PDU pdu = new PDU(bytes, bytesRead);
		String nick;
		switch(pdu.getByte(0)){
		case OpCodes.NICKS:
			String nicks = new String ( pdu.getSubrange(4, pdu.getShort(2) ), "UTF-8" );
			String[] nickList = PDU_Factory.removeZeros(nicks);
			
			Client.INSTANCE.setNick(nickList[0]);
			this.nick = nickList[0];
			
			for(int i = 0; i < nickList.length; i++){
				Client.INSTANCE.addUser(new User(nickList[i]));
			}
			
			break;
			
		case OpCodes.MESSAGE:
			
			if (PDU_Factory.checksum(pdu, 3)) {
				String text = "";
				
				int msgType = pdu.getByte(1);
				int nickLength = pdu.getByte(2);
				//short checksum = pdu.getByte(3);
				int cryptCompByteLength = pdu.getShort(4);
				int timeStamp = (int) pdu.getInt(8);
				byte[] messageByteWithZeroes = pdu.getSubrange(12, cryptCompByteLength);
				byte[] messageByte = PDU_Factory.removeZeros(messageByteWithZeroes);
				byte[] nickname = pdu.getSubrange(12 + cryptCompByteLength, nickLength);
				
				
				switch (msgType) {
				case MsgTypes.TEXT:
					text = new String(pdu.getSubrange(12, (int) pdu.getShort(4)), "UTF-8");
					break;

				case MsgTypes.COMP:
					byte[] compBytePDU = pdu.getSubrange(12, (int) pdu.getShort(4) );
					PDU compPDU = new PDU( compBytePDU, compBytePDU.length );
					
					if(PDU_Factory.checksum(compPDU, 1)){
						int compTextLength = compPDU.getShort(2);
						byte[] compBytes = compPDU.getSubrange(8, compTextLength);
						text = PDU_Factory.deCompress(compBytes);
					} else {
						System.err.println("Checksum missmatch! (MsgTypes.COMP)");
					}
					
					break;
				case MsgTypes.CRYPT:
					
					byte[] cryptBytePDU = pdu.getSubrange(12, (int) pdu.getShort(4) );
					PDU cryptPDU = new PDU( cryptBytePDU, cryptBytePDU.length );
					
					if(PDU_Factory.checksum(cryptPDU, 1) && (this.cryptKey.length != 0)){

						int cryptTextLength = cryptPDU.getShort(2);
						byte[] cryptBytes = cryptPDU.getSubrange(8, cryptTextLength);
						Crypt.decrypt(cryptBytes, cryptBytes.length, this.cryptKey, this.cryptKey.length);
						text = new String( cryptBytes, "UTF-8");
					}else if(this.cryptKey.length != 0){
						System.err.println("Checksum missmatch! (MsgTypes.CRYPT)");
					} 
					break;
				
				case MsgTypes.COMPCRYPT:
					
					PDU cryptCompPDU = new PDU(messageByte, messageByte.length);
					
					int algoritm = cryptCompPDU.getByte(0);
					
					if (PDU_Factory.checksum(cryptCompPDU, 1) && (algoritm == 0)) {
						
						// get all values from the crypted & compressed PDU:
						//checksum = cryptCompPDU.getByte(1);
						cryptCompByteLength = cryptCompPDU.getShort(2);
						
						int compByteLength = cryptCompPDU.getShort(4);
						
						byte[] cryptCompByte = cryptCompPDU.getSubrange(8, cryptCompByteLength);
						
						
						Crypt.decrypt(cryptCompByte, cryptCompByte.length, this.cryptKey, this.cryptKey.length);
						
						PDU compPDU2 = new PDU(cryptCompByte, cryptCompByte.length);
						
						if (PDU_Factory.checksum(compPDU2, 1) && (algoritm == 0)) {
							
							// get all values from compressed PDU:
							compByteLength = compPDU2.getShort(2);
							byte [] compByte = compPDU2.getSubrange(8, compByteLength);
							
							text = PDU_Factory.deCompress(compByte);
							
						} else if(algoritm != 0){
							Client.INSTANCE.println("Can't decompress message, unknown algoritm!");
						} else {
							System.err.println("Checksum missmatch! (MsgTypes.COMPCRYPT stage 2)");
						}
					} else if(algoritm != 0) {
						Client.INSTANCE.println("Can't decrypt message, unknown algoritm!");
					} else {
						System.err.println("Checksum missmatch! (MsgTypes.COMPCRYPT stage 1)");
					}			
					break;
				default:
					break;
				}
				if (text.length() != 0) {
					Client.INSTANCE.println(timeStamp , new String(nickname, "UTF-8") + ": " + text);
				}
				
			}else {
				System.err.println("Checksum missmatch");
			}

			break;
			
		case OpCodes.UINFO:
			Client.INSTANCE.println("Who is:" + InetAddress.getByAddress( pdu.getSubrange(4, 4) ).getHostAddress() );
			break;
			
		case OpCodes.UJOIN:
			nick = new String( pdu.getSubrange(8, pdu.getByte(1)), "UTF-8");
			nick = PDU_Factory.removeZeros(nick)[0];
			
			if( !nick.equals(this.nick) ) {
				Client.INSTANCE.addUser(new User(nick) );
			}
			
			Client.INSTANCE.println( nick + " joined at: " + new Time(pdu.getInt(4)).toString());
			break;
			
		case OpCodes.ULEAVE:
			nick = new String(pdu.getSubrange(8, pdu.getByte(1)), "UTF-8");
			Client.INSTANCE.removeUser(new User( nick ));			
			break;
			
		case OpCodes.UCNICK:
			String nickOld = PDU_Factory.removeZeros(new String( pdu.getSubrange(8, pdu.getByte(1)), "UTF-8" ) )[0];
			String nickNew = PDU_Factory.removeZeros(new String( pdu.getSubrange(8 + pdu.getByte(1), pdu.getByte(2)), "UTF-8" ) )[0];
			
			if(nickOld.equals(this.nick)){
				this.nick = nickNew;
				Client.INSTANCE.setNick(nickNew);
			}
			
			Client.INSTANCE.updateUser(new User(nickNew), new User(nickOld));
			Client.INSTANCE.println( nickOld + " changed name to " + nickNew + " at: " + new Time(pdu.getInt(4)).toString() );
			break;
			
		case OpCodes.CHTOPIC:
			this.topic = new String( pdu.getSubrange(4, pdu.getByte(1)), "UTF-8" );
			Client.INSTANCE.setTopic(this.topic);
			break;
		}
	}
	
	/**
	 * Receives a PDU and sends it through the super class TCP to the server.
	 * @param pdu The PDU to send.
	 * @throws SocketException Thrown to indicate that there is an error creating or accessing a Socket.
	 * @throws IOException Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
	 */
	public void sendPDU(PDU pdu) throws SocketException, IOException {
		if(this.socket != null){
			super.send(pdu.getBytes());
		}else{
			throw new SocketException();
		}
	}
	
	/**
	 * Sends a question to the server for user information.
	 * @param user The user in question.
	 * @throws SocketException Thrown to indicate that there is an error creating or accessing a Socket.
	 * @throws IOException Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
	 */
	public void getUserInfo(User user) throws SocketException, IOException {
			sendPDU(PDU_Factory.whois( user.getNick() ));
	}
	
	/**
	 * Gets the nick used on this server.
	 * @return A nick in string format.
	 */
	public String getNick(){
		return this.nick;
	}
	
	/**
	 * Sends a request to the server to change name if the desired
	 * nickname isn't the same as current nickname.
	 * @param nick The desired nickname.
	 * @throws SocketException Thrown to indicate that there is an error creating or accessing a Socket.
	 * @throws IOException Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
	 */
	public void changeNickName(String nick) throws  SocketException, IOException {
		if(nick != this.nick){
			sendPDU( PDU_Factory.chnick(nick) );
		}
	}
	
	/**
	 * Gets the topic used on this server.
	 * @return The topic in string format.
	 */
	public String getTopic(){
		return this.topic;
	}
	
	/**
	 * Sets the topic on this server, send a request to change
	 * @param topic
	 * @throws SocketException
	 * @throws IOException
	 */
	public void setTopic(String topic) throws SocketException, IOException {
		sendPDU(PDU_Factory.chtopic(topic));
	}
	
	/**
	 * Sends a message to the server.
	 * @param type Type of message.
	 * @param text The text being sent.
	 * @throws SocketException Thrown to indicate that there is an error creating or accessing a Socket.
	 * @throws IOException Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
	 * @throws WrongCryptTypeException Thrown when a cryptype is received with is not recognized. 
	 */
	public void sendMessage(int type, String text) throws SocketException, IOException, WrongCryptTypeException{
		sendPDU(PDU_Factory.message(type, text, this.cryptKey) );
	}
	
	/**
	 * Returns the current crypt key.
	 * @return The crypt key.
	 */
	public String getCrypyKey() {
		String cryptKey;
		try {
			cryptKey = new String(this.cryptKey,"UTF-8");
		} catch (UnsupportedEncodingException e) {
			cryptKey = new String(this.cryptKey);
		}
		return cryptKey;
	}
	
	/**
	 * Sets the crypt key.
	 * @param cryptKey The key to be set.
	 */
	public void setCryptKey(String cryptKey){
		try {
			this.cryptKey = cryptKey.getBytes("UTF-8");
		} catch (UnsupportedEncodingException e) {
			this.cryptKey = cryptKey.getBytes();
		}
	}
	
	/**
	 * Indicates whether some other object is "equal to" this one.
	 */
	@Override
	public boolean equals(Object o){
		if(o == null)
			return false;
		
		if(o.getClass() != this.getClass())
			return false;
		
		ToServer s = (ToServer) o;
		
		if(!s.toString().equals(this.toString()))
			return false;
		
		return true;
	}
	
	/**
	 * Returns a string representation of this thread, including the thread's name, priority, and thread group
	 */
	@Override
	public String toString(){
		return "[" + this.topic +  "]";
	}
	
	/**
	 * Disconnects the client from this server-connection.
	 */
	@Override
	public void disconnect(){
		if(this.socket != null){
			try {
				super.send(PDU_Factory.quit().getBytes());
				super.socket.close();
			} catch (IOException e) {
				Client.INSTANCE.println("Lost connection with server.");
				super.stop = true;
			}
			
		}		
	}
	
	/**
	 * Called from the super class TCP when the server-connection is lost.
	 */
	@Override
	public void disconnectTCP() {
		Client.INSTANCE.println("Lost connection with server.");
		super.stop = true;
		try {
			super.socket.close();
		} catch (IOException e) {
		}
	}
}

